# C++

## 객체지향의 도입

### 은닉

### 캡슐화


### 생성자/소멸자

#### 생성자
- 반환형이 없다.
- 객체 생성시 한 번 호출된다.
- 오버로딩 가능


##### 멤버 이니셜라이저

### 클래스와 배열

#### 객체 배열

#### this 포인터

#### Self-Reference 반환



    + 참조의 정보에 대한 이해


## 복사생성자

    + 클래스 생성시 자동으로 생성되는 것
        - 생성자
        - 소멸자
        - 디폴트 복사 생성자

### 깊은 복사, 얕은 복사
- 디폴트 복사 생성자는 얕은복사
- 깊은

+ 아래 코드에서 문제점 2가지
    - 얕은복사
    - o2에 대한 delete가 없음 -> delete[] o2;  
```cpp
class Obj
{
private:
	//int* p;
public:
	int* p;
	Obj(int n)
	{
		p = new int[n];
	}
	~Obj()
	{
		delete[] p;
	}
};

int main()
{
	Obj o1(10);
	Obj* o2 = new Obj(4);
	o1 = *o2;
}
```
### 복사 생성자의 호출 시점
- 기존의 객체를 사용해서 새로운 객체를 초기화 하는 경우
- call-by-value
- 객체를 반환하되, 참조형으로 반환하지 않는 경우

```cpp
#include <iostream>
using namespace std;

class SoSimple
{
private:
	int num;
public:
	SoSimple(int n) : num(n)
	{ }
	SoSimple(const SoSimple& copy) : num(copy.num)
	{
		cout<<"Called SoSimple(const SoSimple& copy)"<<endl;
	}
	SoSimple& AddNum(int n)
	{
		num+=n;
		return *this;
	}
	void ShowData()
	{
		cout<<"num: "<<num<<endl;
	}
};

SoSimple SimpleFuncObj(SoSimple ob)
{
	cout << "&ob : " << &ob << endl;
	cout<<"return 이전"<<endl;
	return ob;
}

int main(void)
{
	SoSimple obj(7);
	cout << "&obj : " << &obj << endl;
	cout << "&SimpleFuncObj(obj) : " << &SimpleFuncObj(obj) << endl;//.AddNum(30).ShowData();
	obj.ShowData();
	return 0;
}
```

실행 결과

    &obj : 00EFF9D8
    Called SoSimple(const SoSimple& copy)
    &ob : 00EFF8E8
    return 이전
    Called SoSimple(const SoSimple& copy)
    &SimpleFuncObj(obj) : 00EFF900
    num: 7


## static / const




----
